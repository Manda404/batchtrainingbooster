name: CI - BatchTrainingBooster

on:
  push:                       # ğŸš€ Lancement sur push
    branches: [ "main", "feature/**" ]
  pull_request:               # ğŸ” Lancement sur PR
    branches: [ "main" ]

# âš¡ EmpÃªche plusieurs workflows concurrents sur la mÃªme branche
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  tests:
    runs-on: ubuntu-latest    # ğŸ§ Runner GitHub (Linux)

    strategy:
      fail-fast: false        # âŒ Ne coupe pas tous les jobs si un Ã©choue
      matrix:
        python-version: [ "3.11" ]   # ğŸ Version Python testÃ©e (ajoute "3.12" plus tard si besoin)
        include:
          - python-version: "3.11"
            java-version: "17"       # â˜• Version Java compatible PySpark 4.x

    env:
      PIP_DISABLE_PIP_VERSION_CHECK: "1"        # ğŸ”‡ Pas de check pip inutile
      POETRY_VIRTUALENVS_IN_PROJECT: "true"     # ğŸ“¦ venv local (.venv)
      PYTHONPATH: ${{ github.workspace }}/src   # ğŸ› ï¸ Permet d'importer ton code src/
      SPARK_LOCAL_IP: 127.0.0.1                 # ğŸŒ Ã‰vite les soucis rÃ©seau Spark
      PYTHONWARNINGS: "ignore::DeprecationWarning"  # ğŸ™ˆ Cache les DeprecationWarning Python
      JUPYTER_PLATFORM_DIRS: "1"                # âœ… Supprime lâ€™avertissement jupyter_client
      # SPARK_CONF_DIR: ${{ github.workspace }}/tests/resources  # ğŸ“ (Optionnel) si tu ajoutes log4j2.properties
      # SPARK_SUBMIT_OPTS: "-Dlog4j2.formatMsgNoLookups=true -Dorg.apache.logging.log4j.simplelog.StatusLogger.level=OFF"
      # (dÃ©commente si tu veux rÃ©duire le bruit des logs Spark)

    steps:
      # 1) ğŸ“‚ RÃ©cupÃ©ration du code source
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) ğŸ Installation de Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"   # ğŸ“¦ Cache pip global

      # 3) â˜• Installation de Java (Temurin 17)
      - name: Set up Java (Temurin ${{ matrix.java-version }})
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ matrix.java-version }}

      # 4) ğŸ“¦ Installation de Poetry
      - name: Install Poetry
        uses: abatilo/actions-poetry@v3
        with:
          poetry-version: "1.8.3"

      # 5) âš™ï¸ Configuration de Poetry
      - name: Configure Poetry
        run: |
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true
          poetry --version

      # 6) ğŸ§  Mise en cache du venv + dÃ©pendances Poetry
      - name: Cache Poetry and venv
        uses: actions/cache@v4
        with:
          path: |
            .venv
            ~/.cache/pypoetry
          key: ${{ runner.os }}-py${{ matrix.python-version }}-poetry1.8.3-${{ hashFiles('**/poetry.lock') }}-v4
          restore-keys: |
            ${{ runner.os }}-py${{ matrix.python-version }}-poetry1.8.3-

      # 7) ğŸ“¥ Installation des dÃ©pendances (y compris dev : ruff, black, mypy, pytest...)
      - name: Install dependencies (main + dev)
        run: poetry install --no-interaction --no-ansi --no-root --with dev

      # 8) ğŸ¨ VÃ©rification de la qualitÃ© du code
      # ğŸ‘‰ Choisis UNE stratÃ©gie : Ruff fait tout (format + lint) OU Black + Ruff.

      ## Option A : Ruff fait formatage + lint
      - name: Code quality (Ruff format + lint)
        run: |
          echo "ğŸ¨ VÃ©rification du formatage avec Ruff..."
          poetry run ruff format --check src
          
          echo "ğŸ” VÃ©rification du linting avec Ruff..."
          poetry run ruff check src

      ## Option B (si tu prÃ©fÃ¨res Black + Ruff, dÃ©commente et commente Option A ci-dessus)
      # - name: Code quality (Black + Ruff)
      #   run: |
      #     echo "ğŸ¨ VÃ©rification du formatage avec Black..."
      #     poetry run black --check src tests
      #
      #     echo "ğŸ” VÃ©rification du linting avec Ruff..."
      #     poetry run ruff check src tests --output-format=github

      # 9) ğŸ·ï¸ VÃ©rification des types avec mypy
      - name: Type checking (mypy)
        run: |
          echo "ğŸ·ï¸ VÃ©rification des types avec mypy..."
          poetry run mypy --python-version ${{ matrix.python-version }} --explicit-package-bases src

      # 10) ğŸ§ª Lancement des tests unitaires
      - name: Run unit tests (unittest)
        env:
          PYSPARK_PYTHON: python   # Simplifie lâ€™appel de PySpark
          # SPARK_CONF_DIR: ${{ github.workspace }}/tests/resources  # ğŸ“ (Optionnel) si tu ajoutes log4j2.properties
        run: |
          echo "ğŸ§ª ExÃ©cution des tests unitaires..."
          poetry run python -m unittest discover -s tests -p "test_*.py" -v

      # 11) ğŸ“Š (Bonus futur) Rapports de tests / couverture
      # - name: Run tests (pytest + coverage)
      #   run: |
      #     poetry run pytest -q --maxfail=1 --disable-warnings \
      #       --junitxml=reports/junit.xml --cov=src --cov-report=xml:reports/coverage.xml
      #
      # - name: Upload test reports
      #   if: always()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: unit-test-reports
      #     path: reports/
